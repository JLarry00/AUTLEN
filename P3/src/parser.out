Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> roman
Rule 1     roman -> hundreds tens units
Rule 2     hundreds -> low_hundreds
Rule 3     hundreds -> C D
Rule 4     hundreds -> D low_hundreds
Rule 5     hundreds -> C M
Rule 6     low_hundreds -> C low_hundreds
Rule 7     low_hundreds -> lambda
Rule 8     tens -> low_tens
Rule 9     tens -> X L
Rule 10    tens -> L low_tens
Rule 11    tens -> X C
Rule 12    low_tens -> X low_tens
Rule 13    low_tens -> lambda
Rule 14    units -> low_units
Rule 15    units -> I V
Rule 16    units -> V low_units
Rule 17    units -> I X
Rule 18    low_units -> I low_units
Rule 19    low_units -> lambda
Rule 20    lambda -> <empty>

Terminals, with rules where they appear

C                    : 3 5 6 11
D                    : 3 4
I                    : 15 17 18
L                    : 9 10
M                    : 5
V                    : 15 16
X                    : 9 11 12 17
error                : 

Nonterminals, with rules where they appear

hundreds             : 1
lambda               : 7 13 19
low_hundreds         : 2 4 6
low_tens             : 8 10 12
low_units            : 14 16 18
roman                : 0
tens                 : 1
units                : 1

Parsing method: LALR

state 0

    (0) S' -> . roman
    (1) roman -> . hundreds tens units
    (2) hundreds -> . low_hundreds
    (3) hundreds -> . C D
    (4) hundreds -> . D low_hundreds
    (5) hundreds -> . C M
    (6) low_hundreds -> . C low_hundreds
    (7) low_hundreds -> . lambda
    (20) lambda -> .

    C               shift and go to state 4
    D               shift and go to state 5
    X               reduce using rule 20 (lambda -> .)
    L               reduce using rule 20 (lambda -> .)
    I               reduce using rule 20 (lambda -> .)
    V               reduce using rule 20 (lambda -> .)
    $end            reduce using rule 20 (lambda -> .)

    roman                          shift and go to state 1
    hundreds                       shift and go to state 2
    low_hundreds                   shift and go to state 3
    lambda                         shift and go to state 6

state 1

    (0) S' -> roman .



state 2

    (1) roman -> hundreds . tens units
    (8) tens -> . low_tens
    (9) tens -> . X L
    (10) tens -> . L low_tens
    (11) tens -> . X C
    (12) low_tens -> . X low_tens
    (13) low_tens -> . lambda
    (20) lambda -> .

    X               shift and go to state 9
    L               shift and go to state 10
    I               reduce using rule 20 (lambda -> .)
    V               reduce using rule 20 (lambda -> .)
    $end            reduce using rule 20 (lambda -> .)

    tens                           shift and go to state 7
    low_tens                       shift and go to state 8
    lambda                         shift and go to state 11

state 3

    (2) hundreds -> low_hundreds .

    X               reduce using rule 2 (hundreds -> low_hundreds .)
    L               reduce using rule 2 (hundreds -> low_hundreds .)
    I               reduce using rule 2 (hundreds -> low_hundreds .)
    V               reduce using rule 2 (hundreds -> low_hundreds .)
    $end            reduce using rule 2 (hundreds -> low_hundreds .)


state 4

    (3) hundreds -> C . D
    (5) hundreds -> C . M
    (6) low_hundreds -> C . low_hundreds
    (6) low_hundreds -> . C low_hundreds
    (7) low_hundreds -> . lambda
    (20) lambda -> .

    D               shift and go to state 13
    M               shift and go to state 14
    C               shift and go to state 12
    X               reduce using rule 20 (lambda -> .)
    L               reduce using rule 20 (lambda -> .)
    I               reduce using rule 20 (lambda -> .)
    V               reduce using rule 20 (lambda -> .)
    $end            reduce using rule 20 (lambda -> .)

    low_hundreds                   shift and go to state 15
    lambda                         shift and go to state 6

state 5

    (4) hundreds -> D . low_hundreds
    (6) low_hundreds -> . C low_hundreds
    (7) low_hundreds -> . lambda
    (20) lambda -> .

    C               shift and go to state 12
    X               reduce using rule 20 (lambda -> .)
    L               reduce using rule 20 (lambda -> .)
    I               reduce using rule 20 (lambda -> .)
    V               reduce using rule 20 (lambda -> .)
    $end            reduce using rule 20 (lambda -> .)

    low_hundreds                   shift and go to state 16
    lambda                         shift and go to state 6

state 6

    (7) low_hundreds -> lambda .

    X               reduce using rule 7 (low_hundreds -> lambda .)
    L               reduce using rule 7 (low_hundreds -> lambda .)
    I               reduce using rule 7 (low_hundreds -> lambda .)
    V               reduce using rule 7 (low_hundreds -> lambda .)
    $end            reduce using rule 7 (low_hundreds -> lambda .)


state 7

    (1) roman -> hundreds tens . units
    (14) units -> . low_units
    (15) units -> . I V
    (16) units -> . V low_units
    (17) units -> . I X
    (18) low_units -> . I low_units
    (19) low_units -> . lambda
    (20) lambda -> .

    I               shift and go to state 19
    V               shift and go to state 20
    $end            reduce using rule 20 (lambda -> .)

    units                          shift and go to state 17
    low_units                      shift and go to state 18
    lambda                         shift and go to state 21

state 8

    (8) tens -> low_tens .

    I               reduce using rule 8 (tens -> low_tens .)
    V               reduce using rule 8 (tens -> low_tens .)
    $end            reduce using rule 8 (tens -> low_tens .)


state 9

    (9) tens -> X . L
    (11) tens -> X . C
    (12) low_tens -> X . low_tens
    (12) low_tens -> . X low_tens
    (13) low_tens -> . lambda
    (20) lambda -> .

    L               shift and go to state 23
    C               shift and go to state 24
    X               shift and go to state 22
    I               reduce using rule 20 (lambda -> .)
    V               reduce using rule 20 (lambda -> .)
    $end            reduce using rule 20 (lambda -> .)

    low_tens                       shift and go to state 25
    lambda                         shift and go to state 11

state 10

    (10) tens -> L . low_tens
    (12) low_tens -> . X low_tens
    (13) low_tens -> . lambda
    (20) lambda -> .

    X               shift and go to state 22
    I               reduce using rule 20 (lambda -> .)
    V               reduce using rule 20 (lambda -> .)
    $end            reduce using rule 20 (lambda -> .)

    low_tens                       shift and go to state 26
    lambda                         shift and go to state 11

state 11

    (13) low_tens -> lambda .

    I               reduce using rule 13 (low_tens -> lambda .)
    V               reduce using rule 13 (low_tens -> lambda .)
    $end            reduce using rule 13 (low_tens -> lambda .)


state 12

    (6) low_hundreds -> C . low_hundreds
    (6) low_hundreds -> . C low_hundreds
    (7) low_hundreds -> . lambda
    (20) lambda -> .

    C               shift and go to state 12
    X               reduce using rule 20 (lambda -> .)
    L               reduce using rule 20 (lambda -> .)
    I               reduce using rule 20 (lambda -> .)
    V               reduce using rule 20 (lambda -> .)
    $end            reduce using rule 20 (lambda -> .)

    low_hundreds                   shift and go to state 15
    lambda                         shift and go to state 6

state 13

    (3) hundreds -> C D .

    X               reduce using rule 3 (hundreds -> C D .)
    L               reduce using rule 3 (hundreds -> C D .)
    I               reduce using rule 3 (hundreds -> C D .)
    V               reduce using rule 3 (hundreds -> C D .)
    $end            reduce using rule 3 (hundreds -> C D .)


state 14

    (5) hundreds -> C M .

    X               reduce using rule 5 (hundreds -> C M .)
    L               reduce using rule 5 (hundreds -> C M .)
    I               reduce using rule 5 (hundreds -> C M .)
    V               reduce using rule 5 (hundreds -> C M .)
    $end            reduce using rule 5 (hundreds -> C M .)


state 15

    (6) low_hundreds -> C low_hundreds .

    X               reduce using rule 6 (low_hundreds -> C low_hundreds .)
    L               reduce using rule 6 (low_hundreds -> C low_hundreds .)
    I               reduce using rule 6 (low_hundreds -> C low_hundreds .)
    V               reduce using rule 6 (low_hundreds -> C low_hundreds .)
    $end            reduce using rule 6 (low_hundreds -> C low_hundreds .)


state 16

    (4) hundreds -> D low_hundreds .

    X               reduce using rule 4 (hundreds -> D low_hundreds .)
    L               reduce using rule 4 (hundreds -> D low_hundreds .)
    I               reduce using rule 4 (hundreds -> D low_hundreds .)
    V               reduce using rule 4 (hundreds -> D low_hundreds .)
    $end            reduce using rule 4 (hundreds -> D low_hundreds .)


state 17

    (1) roman -> hundreds tens units .

    $end            reduce using rule 1 (roman -> hundreds tens units .)


state 18

    (14) units -> low_units .

    $end            reduce using rule 14 (units -> low_units .)


state 19

    (15) units -> I . V
    (17) units -> I . X
    (18) low_units -> I . low_units
    (18) low_units -> . I low_units
    (19) low_units -> . lambda
    (20) lambda -> .

    V               shift and go to state 28
    X               shift and go to state 29
    I               shift and go to state 27
    $end            reduce using rule 20 (lambda -> .)

    low_units                      shift and go to state 30
    lambda                         shift and go to state 21

state 20

    (16) units -> V . low_units
    (18) low_units -> . I low_units
    (19) low_units -> . lambda
    (20) lambda -> .

    I               shift and go to state 27
    $end            reduce using rule 20 (lambda -> .)

    low_units                      shift and go to state 31
    lambda                         shift and go to state 21

state 21

    (19) low_units -> lambda .

    $end            reduce using rule 19 (low_units -> lambda .)


state 22

    (12) low_tens -> X . low_tens
    (12) low_tens -> . X low_tens
    (13) low_tens -> . lambda
    (20) lambda -> .

    X               shift and go to state 22
    I               reduce using rule 20 (lambda -> .)
    V               reduce using rule 20 (lambda -> .)
    $end            reduce using rule 20 (lambda -> .)

    low_tens                       shift and go to state 25
    lambda                         shift and go to state 11

state 23

    (9) tens -> X L .

    I               reduce using rule 9 (tens -> X L .)
    V               reduce using rule 9 (tens -> X L .)
    $end            reduce using rule 9 (tens -> X L .)


state 24

    (11) tens -> X C .

    I               reduce using rule 11 (tens -> X C .)
    V               reduce using rule 11 (tens -> X C .)
    $end            reduce using rule 11 (tens -> X C .)


state 25

    (12) low_tens -> X low_tens .

    I               reduce using rule 12 (low_tens -> X low_tens .)
    V               reduce using rule 12 (low_tens -> X low_tens .)
    $end            reduce using rule 12 (low_tens -> X low_tens .)


state 26

    (10) tens -> L low_tens .

    I               reduce using rule 10 (tens -> L low_tens .)
    V               reduce using rule 10 (tens -> L low_tens .)
    $end            reduce using rule 10 (tens -> L low_tens .)


state 27

    (18) low_units -> I . low_units
    (18) low_units -> . I low_units
    (19) low_units -> . lambda
    (20) lambda -> .

    I               shift and go to state 27
    $end            reduce using rule 20 (lambda -> .)

    low_units                      shift and go to state 30
    lambda                         shift and go to state 21

state 28

    (15) units -> I V .

    $end            reduce using rule 15 (units -> I V .)


state 29

    (17) units -> I X .

    $end            reduce using rule 17 (units -> I X .)


state 30

    (18) low_units -> I low_units .

    $end            reduce using rule 18 (low_units -> I low_units .)


state 31

    (16) units -> V low_units .

    $end            reduce using rule 16 (units -> V low_units .)

